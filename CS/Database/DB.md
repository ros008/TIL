## 데이터베이스를 사용하는 이유
데이터베이스를 사용하기 전에는 파일 시스템을 이용하여 관리했는데, 이 경우에는 `데이터 종속성`, `중복성`, `무결성 문제`가 발생한다.

## 특징
1. 데이터의 독립성
   - 물리적 독립성: 데이터 베이스 사이즈를 늘리거나 줄일 때 관련된 응용 프로그램을 수정할 필요가 없다.
   - 논리적 독립성: 논리적인 구조를 가지므로 응용 프로그램의 요구를 만족시킬 수 있다.
2. 데이터의 무결성
   - 여러 경로를 통해 잘못된 데이터가 발생하는 경우를 방지하는 기능(데이터의 유효성 검사)
3. 데이터의 보안성
   - 권한이 있는 사용자들만 자원에 접근할 수 있도록 설정
4. 데이터의 일관성
   - 연관된 정보를 논리적인 구조로 관리함(어떤 데이터를 변경했을 때 나머지 데이터와 일치하지 않는 불일치성을 배제함)
5. 데이터 중복 최소화
   - 데이터를 통합 관리함으로써 자료의 중복과 데이터의 중복 문제를 해결할 수 있다.

디스크 I/O를 줄일수록 데이터베이스의 성능은 좋아진다.

### Index  
인덱스란?  
   - 인덱스는 말 그대로 색인이다. 예를 들어 데이터는 책의 내용이고 데이터가 저장된 레코드 주소는 인덱스 목록에 있는 페이지 번호이다.
   - 데이터베이스도 마찬가지로 모든 데이터를 검색해서 찾으면 시간이 오래 걸리니까 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어둔다.
   - DBMS(데이터베이스 관리 시스템)은 항상 정렬된 상태를 유지한다. (즉, 탐색하는데는 빠르지만 값을 추가, 삭제, 수정하는 경우에는 느리다.)

인덱스 자료구조
1. B-Tree
   - 일반적으로 사용되는 알고리즘으로 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱한다.
2. Hash
   - 컬럼의 값으로 해시 값을 계산해서 인덱스하는 알고리즘으로 매우 빠른 검색속도를 가지고 있다.
   - 하지만 값을 변형해서 인덱싱하므로 값의 일부만으로 검색할 때는 hash를 사용할 수 없다.
  
B-tree보다 Hash가 효율적일 것 같지만 SELECT 질의의 조건에 부등호(<>)도 포함되므로 hash에서 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다.

### 클러스터
인덱스에서 클러스터는 물리적으로 인접한 장소에 저장되어 있는 데이터들을 묶어서 저장하는 형태이다. 클러스터 인덱스는 프라이머리 키에 의해 레코드 저장 위치가 결졍된다. 따라서 키를 신중하게 결정하고 사용해야한다.

### 성능과 고려해야할 사항
인덱스를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가된다. INSERT는 인덱스에 대한 데이터를 추가해야하고 DELETE는 인덱스에 존재하는 값은 삭제하지 않고 사용하지 않는다는 표시로 남게 된다. 따라서 row의 수는 그대로이므로 실제 데이터에 ㅂ해 허수 데이터가 많이 존재할 수 있다.

## 정규화
정규화란?  
- 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 구체적으로 말하면 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의되고 그 정규형을 만족하지 못하는 릴레이션을 나누어서 만족하는 릴레이션으로 분해하는 작업이다. 
- 함수적 종속성: 속성들 간의 상호 관계로부터 유도되는 제약조건의 일종(X의 값이 Y의 값을 유일하게 결정하면 X는 Y를 함수적으로 결정한다.)
- 정규형의 조건
  - 분해의 대상인 분해 집합은 무손실 조인을 보장해야 한다.
  - 분해 집합은 함수적 종속성으 보존해야 한다.
